<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C√¥ng c·ª• chuy·ªÉn ƒë·ªïi ·∫£nh chuy√™n nghi·ªáp - H·ªó tr·ª£ 80+ ƒë·ªãnh d·∫°ng</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="./asset/css/style.css">
</head>
<body>
     <header class="doitenhinhanhsticky__header" id="doitenhinhanhsticky__header">
        <!-- render header -->
    </header>
    <!-- ƒêo·∫°n scrip render header -->
    <script>
        fetch('./templates/header.html')
            .then(response => response.text())
            .then(data => {
                document.querySelector("#doitenhinhanhsticky__header").innerHTML = data;
            })
            .catch(error => console.error('L·ªói:', error));
    </script>
    <div class="container" style="margin-top: 115px;">
        <header class="header">
            <h1>üñºÔ∏è Chuy·ªÉn ƒë·ªïi ƒëu√¥i ·∫£nh</h1>
            <p>Chuy·ªÉn ƒë·ªïi ·∫£nh gi·ªØa 80+ ƒë·ªãnh d·∫°ng kh√°c nhau - C√¥ng c·ª• chuy√™n nghi·ªáp nh·∫•t <br>
            </p>
           
            <div class="format-counter">
                <span id="supportedFormats">80+</span> ƒë·ªãnh d·∫°ng ƒë∆∞·ª£c h·ªó tr·ª£
            </div>
        </header>

        <main class="main-content">
            <!-- Upload Section -->
            <!-- Thay th·∫ø ph·∫ßn upload-section trong HTML -->
<div class="upload-section">
    <div class="upload-modes">
        <div class="mode-selector">
            <label class="mode-option">
                <input type="radio" name="uploadMode" value="single" checked>
                <span class="mode-card">
                    <strong>üì∑ Ch·ªçn 1 ·∫£nh</strong>
                    <small>Chuy·ªÉn ƒë·ªïi t·ª´ng ·∫£nh m·ªôt</small>
                </span>
            </label>
            <label class="mode-option">
                <input type="radio" name="uploadMode" value="multiple">
                <span class="mode-card">
                    <strong>üìÅ Ch·ªçn nhi·ªÅu ·∫£nh</strong>
                    <small>X·ª≠ l√Ω h√†ng lo·∫°t</small>
                </span>
            </label>
            <label class="mode-option">
                <input type="radio" name="uploadMode" value="folder">
                <span class="mode-card">
                    <strong>üìÇ Ch·ªçn th∆∞ m·ª•c</strong>
                    <small>T·∫•t c·∫£ ·∫£nh trong folder</small>
                </span>
            </label>
        </div>
    </div>

    <div class="upload-area" id="uploadArea">
        <div class="upload-icon">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" stroke="currentColor" stroke-width="2"/>
                <polyline points="14,2 14,8 20,8" stroke="currentColor" stroke-width="2"/>
                <line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2"/>
                <line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2"/>
            </svg>
        </div>
        <h3 id="uploadTitle">K√©o th·∫£ ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn</h3>
        <p id="uploadDescription">H·ªó tr·ª£: JPG, PNG, GIF, WebP, BMP, TIFF, HEIC, AVIF, RAW v√† 70+ ƒë·ªãnh d·∫°ng kh√°c</p>
        
        <!-- Multiple file inputs for different modes -->
        <input type="file" id="singleFileInput" accept="image/*,.psd,.ai,.eps,.svg,.raw,.dng,.cr2,.cr3,.nef,.arw,.orf,.rw2,.pef,.srf,.sr2,.raf,.mrw,.bay,.erf,.kdc,.mos,.mef,.nr2,.ptx,.rdc,.3fr,.fff,.dcr,.cine,.dpx,.xcf,.kra,.clip,.pdn" hidden>
        <input type="file" id="multipleFileInput" multiple accept="image/*,.psd,.ai,.eps,.svg,.raw,.dng,.cr2,.cr3,.nef,.arw,.orf,.rw2,.pef,.srf,.sr2,.raf,.mrw,.bay,.erf,.kdc,.mos,.mef,.nr2,.ptx,.rdc,.3fr,.fff,.dcr,.cine,.dpx,.xcf,.kra,.clip,.pdn" hidden>
        <input type="file" id="folderInput" webkitdirectory directory multiple hidden>
    </div>
<!-- Supported Formats Display -->
<div class="supported-formats">
    <button class="toggle-formats" id="toggleFormats">
        üìã Xem t·∫•t c·∫£ ƒë·ªãnh d·∫°ng h·ªó tr·ª£
    </button>
    <div class="formats-list" id="formatsList" style="display: none;">
        <div class="format-category">
            <h4>üì∏ ƒê·ªãnh d·∫°ng ph·ªï bi·∫øn</h4>
            <div class="format-tags">
                <span>JPG</span><span>JPEG</span><span>PNG</span><span>GIF</span><span>WebP</span><span>BMP</span><span>TIFF</span>
            </div>
        </div>
        <!-- Th√™m c√°c category kh√°c... -->
    </div>
</div>

    <!-- File Preview Grid -->
    <div class="file-preview-grid" id="filePreviewGrid" style="display: none;">
        <div class="grid-header">
            <h3>üìã Danh s√°ch ·∫£nh ƒë√£ ch·ªçn (<span id="fileCount">0</span>)</h3>
            <div class="grid-controls">
                <button class="control-btn" id="selectAllBtn">‚úÖ Ch·ªçn t·∫•t c·∫£</button>
                <button class="control-btn" id="deselectAllBtn">‚ùå B·ªè ch·ªçn t·∫•t c·∫£</button>
                <button class="control-btn danger" id="removeSelectedBtn">üóëÔ∏è X√≥a ƒë√£ ch·ªçn</button>
                <button class="control-btn" id="addMoreBtn">‚ûï Th√™m ·∫£nh</button>
            </div>
        </div>
        
        <div class="file-grid" id="fileGrid"></div>
        
        <div class="grid-footer">
            <div class="selection-info">
                <span>ƒê√£ ch·ªçn: <strong id="selectedCount">0</strong> / <strong id="totalCount">0</strong></span>
                <span>T·ªïng dung l∆∞·ª£ng: <strong id="totalSize">0 MB</strong></span>
            </div>
        </div>
    </div>

    <!-- Quick Actions for Multiple Files -->
    <div class="quick-actions" id="quickActions" style="display: none;">
        <h3>‚ö° Thao t√°c nhanh</h3>
        <div class="action-buttons">
            <button class="action-btn" id="sortByNameBtn">üî§ S·∫Øp x·∫øp theo t√™n</button>
            <button class="action-btn" id="sortBySizeBtn">üìè S·∫Øp x·∫øp theo k√≠ch th∆∞·ªõc</button>
            <button class="action-btn" id="sortByDateBtn">üìÖ S·∫Øp x·∫øp theo ng√†y</button>
            <button class="action-btn" id="filterImagesBtn">üñºÔ∏è L·ªçc ch·ªâ ·∫£nh</button>
            <button class="action-btn" id="removeSmallBtn">üîç X√≥a ·∫£nh nh·ªè</button>
        </div>
    </div>
</div>


            <!-- Preview Section -->
            <div class="preview-section" id="previewSection" style="display: none;">
                <div class="image-preview">
                    <img id="previewImage" alt="Preview">
                    <div class="image-info">
                        <span id="fileName"></span>
                        <span id="fileSize"></span>
                        <span id="fileDimensions"></span>
                        <span id="fileFormat"></span>
                        <span id="colorDepth"></span>
                    </div>
                </div>
            </div>

            <!-- Conversion Options -->
            <div class="conversion-section" id="conversionSection" style="display: none;">
                <!-- Output Format Categories -->
                <div class="format-selection">
                    <h3>Ch·ªçn ƒë·ªãnh d·∫°ng ƒë·∫ßu ra:</h3>
                    
                    <!-- Popular Formats -->
                    <div class="format-group">
                        <h4>üì∏ ƒê·ªãnh d·∫°ng ph·ªï bi·∫øn</h4>
                        <div class="format-grid">
                            <label class="format-option">
                                <input type="radio" name="format" value="png" checked>
                                <span class="format-card">
                                    <strong>PNG</strong>
                                    <small>Ch·∫•t l∆∞·ª£ng cao, h·ªó tr·ª£ trong su·ªët</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="jpeg">
                                <span class="format-card">
                                    <strong>JPEG</strong>
                                    <small>K√≠ch th∆∞·ªõc nh·ªè, ph√π h·ª£p web</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="webp">
                                <span class="format-card">
                                    <strong>WebP</strong>
                                    <small>Hi·ªán ƒë·∫°i, t·ªëi ∆∞u cho web</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="gif">
                                <span class="format-card">
                                    <strong>GIF</strong>
                                    <small>H·ªó tr·ª£ animation</small>
                                </span>
                            </label>
                        </div>
                    </div>

                    <!-- Modern Formats -->
                    <div class="format-group">
                        <h4>üÜï ƒê·ªãnh d·∫°ng hi·ªán ƒë·∫°i</h4>
                        <div class="format-grid">
                            <label class="format-option">
                                <input type="radio" name="format" value="avif">
                                <span class="format-card">
                                    <strong>AVIF</strong>
                                    <small>N√©n t·ªët nh·∫•t, t∆∞∆°ng lai</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="heic">
                                <span class="format-card">
                                    <strong>HEIC</strong>
                                    <small>Apple, ch·∫•t l∆∞·ª£ng cao</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="jp2">
                                <span class="format-card">
                                    <strong>JPEG 2000</strong>
                                    <small>N√©n wavelet, chuy√™n nghi·ªáp</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="jxr">
                                <span class="format-card">
                                    <strong>JPEG XR</strong>
                                    <small>Microsoft HD Photo</small>
                                </span>
                            </label>
                        </div>
                    </div>

                    <!-- Professional Formats -->
                    <div class="format-group">
                        <h4>üé® ƒê·ªãnh d·∫°ng chuy√™n nghi·ªáp</h4>
                        <div class="format-grid">
                            <label class="format-option">
                                <input type="radio" name="format" value="tiff">
                                <span class="format-card">
                                    <strong>TIFF</strong>
                                    <small>In ·∫•n ch·∫•t l∆∞·ª£ng cao</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="bmp">
                                <span class="format-card">
                                    <strong>BMP</strong>
                                    <small>Kh√¥ng n√©n, Windows</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="tga">
                                <span class="format-card">
                                    <strong>TGA</strong>
                                    <small>Gaming, alpha channel</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="exr">
                                <span class="format-card">
                                    <strong>OpenEXR</strong>
                                    <small>HDR, VFX chuy√™n nghi·ªáp</small>
                                </span>
                            </label>
                        </div>
                    </div>

                    <!-- System & Icon Formats -->
                    <div class="format-group">
                        <h4>üñ•Ô∏è Icon & H·ªá th·ªëng</h4>
                        <div class="format-grid">
                            <label class="format-option">
                                <input type="radio" name="format" value="ico">
                                <span class="format-card">
                                    <strong>ICO</strong>
                                    <small>Windows icon</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="icns">
                                <span class="format-card">
                                    <strong>ICNS</strong>
                                    <small>macOS icon</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="svg">
                                <span class="format-card">
                                    <strong>SVG</strong>
                                    <small>Vector, c√≥ th·ªÉ scale</small>
                                </span>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="format" value="pdf">
                                <span class="format-card">
                                    <strong>PDF</strong>
                                    <small>T√†i li·ªáu, in ·∫•n</small>
                                </span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Advanced Settings -->
                <div class="advanced-settings">
                    <h3>‚öôÔ∏è C√†i ƒë·∫∑t n√¢ng cao:</h3>
                    
                    <!-- Quality Settings -->
                        <div class="setting-group">
                            <label for="qualitySlider">Ch·∫•t l∆∞·ª£ng: <span id="qualityValue">90</span>%</label>
                            <input type="range" id="qualitySlider" min="10" max="100" value="90">
                        <div class="quality-warning" id="qualityWarning" style="display: none;">
                            ‚ö†Ô∏è <strong>L∆∞u √Ω:</strong> Canvas API c√≥ th·ªÉ t·∫°o file l·ªõn h∆°n ·∫£nh g·ªëc do ph·∫£i gi·∫£i n√©n v√† n√©n l·∫°i. 
                            V·ªõi quality th·∫•p, n√™n s·ª≠ d·ª•ng c√¥ng c·ª• n√©n chuy√™n d·ª•ng.
                        </div>
                            <div class="quality-presets">
                                <button class="preset-btn" data-quality="60">Web (60%)</button>
                                <button class="preset-btn" data-quality="80">Chu·∫©n (80%)</button>
                                <button class="preset-btn" data-quality="90">Cao (90%)</button>
                                <button class="preset-btn" data-quality="100">T·ªëi ƒëa (100%)</button>
                            </div>
                            

                        </div>
                        
                        <!-- Sharpen Settings - TH√äM M·ªöI -->
                        <div class="sharpen-group">
                            <label>
                                <input type="checkbox" id="sharpenEnabled"> L√†m n√©t ·∫£nh (Sharpen)
                            </label>
                            <div class="sharpen-control" id="sharpenControl">
                                <label for="sharpenSlider">ƒê·ªô n√©t: <span id="sharpenValue">30</span>%</label>
                                <input type="range" id="sharpenSlider" min="0" max="100" value="30">
                                <div class="sharpen-presets">
                                    <button class="sharpen-preset" data-sharpen="10">Nh·∫π (10%)</button>
                                    <button class="sharpen-preset" data-sharpen="30">V·ª´a (30%)</button>
                                    <button class="sharpen-preset" data-sharpen="50">M·∫°nh (50%)</button>
                                    <button class="sharpen-preset" data-sharpen="80">R·∫•t m·∫°nh (80%)</button>
                                </div>
                                <div class="compression-info">
                                    üí° <strong>Tip:</strong> L√†m n√©t gi√∫p ·∫£nh r√µ h∆°n sau khi n√©n v√† gi·∫£m dung l∆∞·ª£ng file
                                </div>
                            </div>
                        </div>


                    <!-- Resize Settings -->
                    <div class="setting-group">
                        <label>
                            <input type="checkbox" id="resizeEnabled"> Thay ƒë·ªïi k√≠ch th∆∞·ªõc
                        </label>
                        <div class="resize-inputs" id="resizeInputs" style="display: none;">
                            <div class="dimension-inputs">
                                <input type="number" id="widthInput" placeholder="Chi·ªÅu r·ªông">
                                <span>√ó</span>
                                <input type="number" id="heightInput" placeholder="Chi·ªÅu cao">
                            </div>
                            <div class="resize-options">
                                <label>
                                    <input type="checkbox" id="maintainRatio" checked> Gi·ªØ t·ª∑ l·ªá
                                </label>
                                <div class="size-presets">
                                    <button class="size-preset" data-width="1920" data-height="1080">Full HD</button>
                                    <button class="size-preset" data-width="1280" data-height="720">HD</button>
                                    <button class="size-preset" data-width="800" data-height="600">Web</button>
                                    <button class="size-preset" data-width="400" data-height="300">Thumbnail</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Color Settings -->
                    <div class="setting-group">
                        <label for="colorSpace">Kh√¥ng gian m√†u:</label>
                        <select id="colorSpace">
                            <option value="srgb">sRGB (Web)</option>
                            <option value="adobe-rgb">Adobe RGB</option>
                            <option value="prophoto-rgb">ProPhoto RGB</option>
                            <option value="rec2020">Rec. 2020</option>
                        </select>
                    </div>

                    <!-- Metadata Settings -->
                    <div class="setting-group">
                        <label>
                            <input type="checkbox" id="preserveMetadata" checked> Gi·ªØ metadata (EXIF, IPTC)
                        </label>
                        <label>
                            <input type="checkbox" id="stripMetadata"> X√≥a metadata (gi·∫£m dung l∆∞·ª£ng)
                        </label>
                    </div>
                </div>

                <!-- Batch Processing -->
                <div class="batch-section">
                    <h3>üì¶ X·ª≠ l√Ω h√†ng lo·∫°t:</h3>
                    <label>
                        <input type="checkbox" id="batchMode"> Ch·∫ø ƒë·ªô x·ª≠ l√Ω nhi·ªÅu ·∫£nh
                    </label>
                    <div class="batch-controls" id="batchControls" style="display: none;">
                        <input type="file" id="batchInput" multiple accept="image/*" hidden>
                        <button class="batch-select-btn" id="batchSelectBtn">
                            üìÅ Ch·ªçn nhi·ªÅu ·∫£nh
                        </button>
                        <div class="batch-list" id="batchList"></div>
                    </div>
                </div>

                <!-- Convert Button -->
                <button class="convert-btn" id="convertBtn">
                    <span>üîÑ Chuy·ªÉn ƒë·ªïi ·∫£nh</span>
                </button>
            </div>

            <!-- Download Section -->
            <div class="download-section" id="downloadSection" style="display: none;">
                <div class="download-preview">
                    <img id="convertedImage" alt="Converted">
                    <div class="download-info">
                        <h3>‚úÖ Chuy·ªÉn ƒë·ªïi th√†nh c√¥ng!</h3>
                        <div class="conversion-stats">
                            <div class="stat-item">
                                <span class="stat-label">ƒê·ªãnh d·∫°ng:</span>
                                <span id="outputFormat">-</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">K√≠ch th∆∞·ªõc:</span>
                                <span id="outputDimensions">-</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Dung l∆∞·ª£ng g·ªëc:</span>
                                <span id="originalSize">-</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Dung l∆∞·ª£ng m·ªõi:</span>
                                <span id="newSize">-</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">T·ª∑ l·ªá n√©n:</span>
                                <span id="compressionRatio">-</span>
                            </div>
                        </div>
                        <div class="download-actions">
                            <button class="download-btn" id="downloadBtn">
                                üì• T·∫£i xu·ªëng
                            </button>
                            <button class="download-all-btn" id="downloadAllBtn" style="display: none;">
                                üì¶ T·∫£i xu·ªëng t·∫•t c·∫£ (ZIP)
                            </button>
                            <button class="reset-btn" id="resetBtn">
                                üîÑ Chuy·ªÉn ƒë·ªïi ·∫£nh kh√°c
                            </button>
                        </div>
                    </div>

                </div>
            </div>
        </main>
    </div>
    <footer class="dvnt-footer" id="dvnt-footer"></footer>
        <script>
        fetch('./templates/footer.html')
            .then(response => response.text())
            .then(data => {
                document.querySelector("#dvnt-footer").innerHTML = data;
            })
            .catch(error => console.error('L·ªói:', error));
    </script>
    <script>
        
    class MultipleImageHandler {
        addShowMoreSection() {
    const grid = document.getElementById('fileGrid');
    const existingSection = document.getElementById('showMoreSection');
    
    // X√≥a section c≈© n·∫øu c√≥
    if (existingSection) {
        existingSection.remove();
    }

    // Ch·ªâ th√™m n√∫t n·∫øu c√≥ nhi·ªÅu h∆°n 10 ·∫£nh
    if (this.selectedFiles.size > this.showLimit) {
        const showMoreSection = document.createElement('div');
        showMoreSection.id = 'showMoreSection';
        showMoreSection.className = 'show-more-section';
        showMoreSection.style.gridColumn = '1 / -1'; // Span to√†n b·ªô grid
        
        const hiddenCount = this.selectedFiles.size - this.currentShowCount;
        const buttonText = this.isExpanded ? 
            'üì§ Thu g·ªçn' : 
            `üëÅÔ∏è Xem th√™m (${hiddenCount} ·∫£nh)`;
        
        showMoreSection.innerHTML = `
            <button class="show-more-btn ${this.isExpanded ? 'collapse' : ''}" id="showMoreBtn">
                ${buttonText}
            </button>
            <div class="show-more-info">
                Hi·ªÉn th·ªã ${this.currentShowCount} / ${this.selectedFiles.size} ·∫£nh
            </div>
        `;

        // Th√™m event listener
        const showMoreBtn = showMoreSection.querySelector('#showMoreBtn');
        showMoreBtn.addEventListener('click', () => this.toggleShowMore());

        grid.appendChild(showMoreSection);
    }
}

updateShowMoreButton() {
    const showMoreBtn = document.getElementById('showMoreBtn');
    const showMoreInfo = document.querySelector('.show-more-info');
    
    if (showMoreBtn && this.selectedFiles.size > this.showLimit) {
        const hiddenCount = this.selectedFiles.size - this.currentShowCount;
        const buttonText = this.isExpanded ? 
            'üì§ Thu g·ªçn' : 
            `üëÅÔ∏è Xem th√™m (${hiddenCount} ·∫£nh)`;
        
        showMoreBtn.innerHTML = buttonText;
        showMoreBtn.className = `show-more-btn ${this.isExpanded ? 'collapse' : ''}`;
        
        if (showMoreInfo) {
            showMoreInfo.textContent = `Hi·ªÉn th·ªã ${this.currentShowCount} / ${this.selectedFiles.size} ·∫£nh`;
        }
    }
}

toggleShowMore() {
    const grid = document.getElementById('fileGrid');
    const hiddenItems = grid.querySelectorAll('.file-item.hidden-item');
    const visibleItems = grid.querySelectorAll('.file-item.visible-item');

    if (!this.isExpanded) {
        // Logic tƒÉng theo chu·ªói: 10 ‚Üí 20 ‚Üí 40 ‚Üí 80 ‚Üí 160...
        let newShowCount;
        
        if (this.currentShowCount <= 10) {
            newShowCount = 20;
        } else if (this.currentShowCount <= 20) {
            newShowCount = 40;
        } else if (this.currentShowCount <= 40) {
            newShowCount = 80;
        } else {
            // Nh√¢n ƒë√¥i cho c√°c gi√° tr·ªã l·ªõn h∆°n
            newShowCount = this.currentShowCount * 2;
        }
        
        // Kh√¥ng v∆∞·ª£t qu√° t·ªïng s·ªë ·∫£nh
        newShowCount = Math.min(newShowCount, this.selectedFiles.size);
        
        const itemsToShow = newShowCount - this.currentShowCount;
        
        // Hi·ªÉn th·ªã c√°c item m·ªõi v·ªõi animation
        for (let i = 0; i < itemsToShow && i < hiddenItems.length; i++) {
            const item = hiddenItems[i];
            item.style.display = 'block';
            item.classList.remove('hidden-item');
            item.classList.add('visible-item', 'show-animation');
            
            // X√≥a animation class sau khi ho√†n th√†nh
            setTimeout(() => {
                item.classList.remove('show-animation');
            }, 300);
        }
        
        this.currentShowCount = newShowCount;
        
        // N·∫øu ƒë√£ hi·ªÉn th·ªã h·∫øt th√¨ ƒë√°nh d·∫•u l√† expanded
        if (this.currentShowCount >= this.selectedFiles.size) {
            this.isExpanded = true;
        }
    } else {
        // Thu g·ªçn: ch·ªâ hi·ªÉn th·ªã 10 ·∫£nh ƒë·∫ßu
        visibleItems.forEach((item, index) => {
            if (index >= this.showLimit) {
                item.style.display = 'none';
                item.classList.remove('visible-item');
                item.classList.add('hidden-item');
            }
        });
        
        this.currentShowCount = this.showLimit; // Reset v·ªÅ 10
        this.isExpanded = false;
    }

    this.updateShowMoreButton();
    this.updateStats();
}


    constructor(converter) {
        this.converter = converter;
        this.selectedFiles = new Map();
        this.uploadMode = 'single';
        this.showLimit = 10; // S·ªë l∆∞·ª£ng ·∫£nh hi·ªÉn th·ªã ban ƒë·∫ßu
        this.currentShowCount = 10; // S·ªë l∆∞·ª£ng hi·ªán t·∫°i ƒëang hi·ªÉn th·ªã
        this.isExpanded = false; // Tr·∫°ng th√°i m·ªü r·ªông
        this.initializeMultipleHandling();
    }
    
    async downloadAllImages() {
    if (this.converter.convertedImages.length === 0) {
        alert('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ t·∫£i xu·ªëng!');
        return;
    }
    
    if (typeof JSZip === 'undefined') {
        this.downloadImagesIndividually();
        return;
    }
    
    try {
        const zip = new JSZip();
        
        this.converter.convertedImages.forEach((result, index) => {
            // T√™n file theo format: dvnt_1.jpg, dvnt_2.jpg, ...
            const fileName = `dvnt_${index + 1}.${result.format}`;
            const base64Data = result.convertedDataUrl.split(',')[1];
            zip.file(fileName, base64Data, { base64: true });
        });
        
        const zipBlob = await zip.generateAsync({ 
            type: 'blob',
            compression: "DEFLATE",
            compressionOptions: { level: 9 } // N√©n ZIP t·ªëi ƒëa
        });
        
        const link = document.createElement('a');
        link.download = `dvnt_images_${Date.now()}.zip`;
        link.href = URL.createObjectURL(zipBlob);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
        
    } catch (error) {
        console.error('ZIP creation failed:', error);
        this.downloadImagesIndividually();
    }
}

downloadImagesIndividually() {
    this.converter.convertedImages.forEach((result, index) => {
        setTimeout(() => {
            const fileName = `dvnt_${index + 1}.${result.format}`;
            const link = document.createElement('a');
            link.download = fileName;
            link.href = result.convertedDataUrl;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }, index * 500);
    });
}


    initializeMultipleHandling() {
        // Mode selector
        document.querySelectorAll('input[name="uploadMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => this.handleModeChange(e.target.value));
        });

        // File inputs
        const singleInput = document.getElementById('singleFileInput');
        if (singleInput) {
            singleInput.addEventListener('change', (e) => {
                this.handleSingleFileSelect(e.target.files);
            });
        }

        const multipleInput = document.getElementById('multipleFileInput');
        if (multipleInput) {
            multipleInput.addEventListener('change', (e) => {
                this.handleMultipleFileSelect(e.target.files);
            });
        }

        const folderInput = document.getElementById('folderInput');
        if (folderInput) {
            folderInput.addEventListener('change', (e) => {
                this.handleFolderSelect(e.target.files);
            });
        }

        // Grid controls
        const selectAllBtn = document.getElementById('selectAllBtn');
        if (selectAllBtn) {
            selectAllBtn.addEventListener('click', () => this.selectAll());
        }

        const deselectAllBtn = document.getElementById('deselectAllBtn');
        if (deselectAllBtn) {
            deselectAllBtn.addEventListener('click', () => this.deselectAll());
        }

        const removeSelectedBtn = document.getElementById('removeSelectedBtn');
        if (removeSelectedBtn) {
            removeSelectedBtn.addEventListener('click', () => this.removeSelected());
        }

        const addMoreBtn = document.getElementById('addMoreBtn');
        if (addMoreBtn) {
            addMoreBtn.addEventListener('click', () => this.addMoreFiles());
        }

        // Quick actions
        const sortByNameBtn = document.getElementById('sortByNameBtn');
        if (sortByNameBtn) {
            sortByNameBtn.addEventListener('click', () => this.sortFiles('name'));
        }

        // Upload area click handler
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) {
            uploadArea.addEventListener('click', (e) => {
                if (e.target === uploadArea || e.target.closest('.upload-icon') || e.target.tagName === 'H3' || e.target.tagName === 'P') {
                    this.triggerFileInput();
                }
            });
        }
    }

    handleModeChange(mode) {
        this.uploadMode = mode;
        this.updateUploadAreaText();
        this.clearSelectedFiles();
    }

    updateUploadAreaText() {
        const title = document.getElementById('uploadTitle');
        const description = document.getElementById('uploadDescription');

        switch (this.uploadMode) {
            case 'single':
                title.textContent = 'K√©o th·∫£ ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn';
                description.textContent = 'Ch·ªçn 1 ·∫£nh ƒë·ªÉ chuy·ªÉn ƒë·ªïi';
                break;
            case 'multiple':
                title.textContent = 'K√©o th·∫£ nhi·ªÅu ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn';
                description.textContent = 'Ch·ªçn nhi·ªÅu ·∫£nh ƒë·ªÉ x·ª≠ l√Ω h√†ng lo·∫°t';
                break;
            case 'folder':
                title.textContent = 'Click ƒë·ªÉ ch·ªçn th∆∞ m·ª•c ch·ª©a ·∫£nh';
                description.textContent = 'Ch·ªçn to√†n b·ªô th∆∞ m·ª•c ƒë·ªÉ x·ª≠ l√Ω t·∫•t c·∫£ ·∫£nh';
                break;
        }
    }

    triggerFileInput() {
        console.log('Triggering file input for mode:', this.uploadMode);
        
        switch (this.uploadMode) {
            case 'single':
                const singleInput = document.getElementById('singleFileInput');
                if (singleInput) singleInput.click();
                break;
            case 'multiple':
                const multipleInput = document.getElementById('multipleFileInput');
                if (multipleInput) multipleInput.click();
                break;
            case 'folder':
                const folderInput = document.getElementById('folderInput');
                if (folderInput) folderInput.click();
                break;
            default:
                console.error('Unknown upload mode:', this.uploadMode);
        }
    }

    handleSingleFileSelect(files) {
        if (files.length > 0) {
            this.clearSelectedFiles();
            this.addFile(files[0]);
            this.converter.processFile(files[0]);
        }
    }

    handleMultipleFileSelect(files) {
        this.addFiles(Array.from(files));
    }

    handleFolderSelect(files) {
        const imageFiles = Array.from(files).filter(file => 
            file.type.startsWith('image/') || this.converter.isRawFormat(file.name)
        );
        this.addFiles(imageFiles);
    }

    addFiles(files) {
        files.forEach(file => this.addFile(file));
        this.updateDisplay();
        this.showMultipleFileInterface();
    }

    addFile(file) {
        if (this.converter.validateImageFile(file)) {
            const fileId = this.generateFileId(file);
            this.selectedFiles.set(fileId, {
                file: file,
                selected: true,
                status: 'ready',
                preview: null,
                converted: null
            });
        }
    }

    generateFileId(file) {
        return `${file.name}_${file.size}_${file.lastModified}`;
    }

    showMultipleFileInterface() {
    document.getElementById('filePreviewGrid').style.display = 'block';
    document.getElementById('quickActions').style.display = 'block';
    this.converter.conversionSection.style.display = 'block';
    
    // Ki·ªÉm tra v√† hi·ªÉn th·ªã n√∫t "Xem th√™m" n·∫øu c·∫ßn
    this.updateShowMoreButton();
}


    updateDisplay() {
    this.updateFileGrid();
    this.updateStats();
    this.updateShowMoreButton();
}


    async updateFileGrid() {
    const grid = document.getElementById('fileGrid');
    grid.innerHTML = '';

    let index = 0;
    for (const [fileId, fileData] of this.selectedFiles) {
        const fileItem = await this.createFileItem(fileId, fileData);
        
        // Th√™m class ƒë·ªÉ ki·ªÉm so√°t hi·ªÉn th·ªã
        if (index >= this.currentShowCount) {
            fileItem.style.display = 'none';
            fileItem.classList.add('hidden-item');
        } else {
            fileItem.classList.add('visible-item');
        }
        
        grid.appendChild(fileItem);
        index++;
    }

    // Th√™m section cho n√∫t "Xem th√™m"
    this.addShowMoreSection();
}


    async createFileItem(fileId, fileData) {
        const item = document.createElement('div');
        item.className = `file-item ${fileData.selected ? 'selected' : ''}`;
        item.dataset.fileId = fileId;

        const preview = await this.createFilePreview(fileData.file);
        
        item.innerHTML = `
            <input type="checkbox" class="file-checkbox" ${fileData.selected ? 'checked' : ''}>
            <div class="file-preview">${preview}</div>
            <div class="file-info">
                <div class="file-name" title="${fileData.file.name}">${fileData.file.name}</div>
                <div class="file-details">
                    <span>${this.converter.formatFileSize(fileData.file.size)}</span>
                    <span>${this.getFileDimensions(fileData.file)}</span>
                </div>
                <div class="file-status ${fileData.status}">${this.getStatusText(fileData.status)}</div>
                <div class="file-actions">
                    <button class="file-action-btn preview" onclick="multipleHandler.previewFile('${fileId}')">üëÅÔ∏è</button>
                    <button class="file-action-btn remove" onclick="multipleHandler.removeFile('${fileId}')">üóëÔ∏è</button>
                </div>
            </div>
        `;

        const checkbox = item.querySelector('.file-checkbox');
        checkbox.addEventListener('change', (e) => {
            this.toggleFileSelection(fileId, e.target.checked);
        });

        item.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox' && !e.target.classList.contains('file-action-btn')) {
                checkbox.checked = !checkbox.checked;
                this.toggleFileSelection(fileId, checkbox.checked);
            }
        });

        return item;
    }

    async createFilePreview(file) {
        if (file.type.startsWith('image/')) {
            try {
                const dataUrl = await this.fileToDataUrl(file);
                return `<img src="${dataUrl}" alt="Preview">`;
            } catch (error) {
                return this.getFileIcon(file);
            }
        } else {
            return this.getFileIcon(file);
        }
    }

    fileToDataUrl(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    getFileIcon(file) {
        const ext = file.name.split('.').pop().toLowerCase();
        const icons = {
            'psd': 'üé®', 'ai': 'üé®', 'eps': 'üìÑ',
            'raw': 'üì∑', 'dng': 'üì∑', 'cr2': 'üì∑', 'nef': 'üì∑',
            'svg': 'üñºÔ∏è', 'pdf': 'üìÑ'
        };
        return icons[ext] || 'üìÑ';
    }

    getFileDimensions(file) {
        return 'Loading...';
    }

    getStatusText(status) {
        const statusTexts = {
            'ready': 'S·∫µn s√†ng',
            'processing': 'ƒêang x·ª≠ l√Ω',
            'completed': 'Ho√†n th√†nh',
            'error': 'L·ªói'
        };
        return statusTexts[status] || status;
    }

    toggleFileSelection(fileId, selected) {
        if (this.selectedFiles.has(fileId)) {
            this.selectedFiles.get(fileId).selected = selected;
            this.updateFileItemAppearance(fileId, selected);
            this.updateStats();
        }
    }

    updateFileItemAppearance(fileId, selected) {
        const item = document.querySelector(`[data-file-id="${fileId}"]`);
        if (item) {
            item.classList.toggle('selected', selected);
        }
    }

    updateStats() {
        const total = this.selectedFiles.size;
        const selected = Array.from(this.selectedFiles.values()).filter(f => f.selected).length;
        const totalSize = Array.from(this.selectedFiles.values())
            .filter(f => f.selected)
            .reduce((sum, f) => sum + f.file.size, 0);

        document.getElementById('fileCount').textContent = total;
        document.getElementById('selectedCount').textContent = selected;
        document.getElementById('totalCount').textContent = total;
        document.getElementById('totalSize').textContent = this.converter.formatFileSize(totalSize);
    }

    selectAll() {
        this.selectedFiles.forEach((fileData, fileId) => {
            fileData.selected = true;
            this.updateFileItemAppearance(fileId, true);
            const checkbox = document.querySelector(`[data-file-id="${fileId}"] .file-checkbox`);
            if (checkbox) checkbox.checked = true;
        });
        this.updateStats();
    }

    deselectAll() {
        this.selectedFiles.forEach((fileData, fileId) => {
            fileData.selected = false;
            this.updateFileItemAppearance(fileId, false);
            const checkbox = document.querySelector(`[data-file-id="${fileId}"] .file-checkbox`);
            if (checkbox) checkbox.checked = false;
        });
        this.updateStats();
    }

    removeSelected() {
        const toRemove = [];
        this.selectedFiles.forEach((fileData, fileId) => {
            if (fileData.selected) {
                toRemove.push(fileId);
            }
        });
        
        toRemove.forEach(fileId => {
            this.selectedFiles.delete(fileId);
            const item = document.querySelector(`[data-file-id="${fileId}"]`);
            if (item) item.remove();
        });
        
        this.updateStats();
        
        if (this.selectedFiles.size === 0) {
            this.hideMultipleFileInterface();
        }
    }

    removeFile(fileId) {
        this.selectedFiles.delete(fileId);
        const item = document.querySelector(`[data-file-id="${fileId}"]`);
        if (item) item.remove();
        this.updateStats();
        
        if (this.selectedFiles.size === 0) {
            this.hideMultipleFileInterface();
        }
    }

    addMoreFiles() {
        this.triggerFileInput();
    }

    hideMultipleFileInterface() {
        document.getElementById('filePreviewGrid').style.display = 'none';
        document.getElementById('quickActions').style.display = 'none';
    }

    clearSelectedFiles() {
        this.selectedFiles.clear();
        this.hideMultipleFileInterface();
    }

    sortFiles(criteria) {
        const filesArray = Array.from(this.selectedFiles.entries());
        
        filesArray.sort((a, b) => {
            const [, fileDataA] = a;
            const [, fileDataB] = b;
            
            switch (criteria) {
                case 'name':
                    return fileDataA.file.name.localeCompare(fileDataB.file.name);
                case 'size':
                    return fileDataB.file.size - fileDataA.file.size;
                case 'date':
                    return fileDataB.file.lastModified - fileDataA.file.lastModified;
                default:
                    return 0;
            }
        });
        
        this.selectedFiles = new Map(filesArray);
        this.updateFileGrid();
    }

    filterImages() {
        const toRemove = [];
        this.selectedFiles.forEach((fileData, fileId) => {
            if (!fileData.file.type.startsWith('image/') && 
                !this.converter.isRawFormat(fileData.file.name)) {
                toRemove.push(fileId);
            }
        });
        
        toRemove.forEach(fileId => this.removeFile(fileId));
    }

    removeSmallImages() {
        const minSize = 100 * 1024;
        const toRemove = [];
        
        this.selectedFiles.forEach((fileData, fileId) => {
            if (fileData.file.size < minSize) {
                toRemove.push(fileId);
            }
        });
        
        toRemove.forEach(fileId => this.removeFile(fileId));
    }

    previewFile(fileId) {
        const fileData = this.selectedFiles.get(fileId);
        if (fileData) {
            this.converter.processFile(fileData.file);
        }
    }

    getSelectedFiles() {
        return Array.from(this.selectedFiles.values())
            .filter(fileData => fileData.selected)
            .map(fileData => fileData.file);
    }

    async convertAllSelected() {
        const selectedFiles = this.getSelectedFiles();
        if (selectedFiles.length === 0) {
            alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh ƒë·ªÉ chuy·ªÉn ƒë·ªïi!');
            return;
        }

        this.showBatchProgress();
        
        this.converter.convertBtn.classList.add('loading');
        this.converter.convertBtn.innerHTML = '<span>üîÑ ƒêang x·ª≠ l√Ω h√†ng lo·∫°t...</span>';
        
        const results = [];
        
        try {
            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                const fileId = this.generateFileId(file);
                
                try {
                    this.updateFileStatus(fileId, 'processing');
                    
                    const img = await this.converter.loadImageFromFile(file);
                    const result = await this.converter.processImageConversion(file, img);
                    results.push(result);
                    
                    this.updateFileStatus(fileId, 'completed');
                    
                } catch (error) {
                    console.error(`Error converting ${file.name}:`, error);
                    this.updateFileStatus(fileId, 'error');
                }
                
                this.updateBatchProgress((i + 1) / selectedFiles.length * 100);
            }
            
            this.converter.convertedImages = results;
            
            if (results.length > 0) {
                this.converter.displayBatchResults();
            } else {
                alert('Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi th√†nh c√¥ng!');
            }
            
        } catch (error) {
            console.error('Batch conversion error:', error);
            alert('C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω h√†ng lo·∫°t!');
        } finally {
            this.converter.convertBtn.classList.remove('loading');
            this.converter.convertBtn.innerHTML = '<span>üîÑ Chuy·ªÉn ƒë·ªïi ·∫£nh</span>';
            this.hideBatchProgress();
        }
    }

    updateFileStatus(fileId, status) {
        if (this.selectedFiles.has(fileId)) {
            this.selectedFiles.get(fileId).status = status;
            const item = document.querySelector(`[data-file-id="${fileId}"]`);
            if (item) {
                const statusElement = item.querySelector('.file-status');
                statusElement.className = `file-status ${status}`;
                statusElement.textContent = this.getStatusText(status);
                item.classList.toggle('processing', status === 'processing');
            }
        }
    }

    showBatchProgress() {
        const progressHtml = `
            <div class="batch-progress">
                <div class="batch-progress-fill" id="batchProgressFill"></div>
            </div>
            <div class="batch-progress-text" id="batchProgressText">ƒêang x·ª≠ l√Ω... 0%</div>
        `;
        
        const progressContainer = document.createElement('div');
        progressContainer.innerHTML = progressHtml;
        progressContainer.id = 'batchProgressContainer';
        
        document.getElementById('filePreviewGrid').appendChild(progressContainer);
    }

    updateBatchProgress(percentage) {
        const fill = document.getElementById('batchProgressFill');
        const text = document.getElementById('batchProgressText');
        
        if (fill && text) {
            fill.style.width = `${percentage}%`;
            text.textContent = `ƒêang x·ª≠ l√Ω... ${Math.round(percentage)}%`;
        }
    }

    hideBatchProgress() {
        const container = document.getElementById('batchProgressContainer');
        if (container) {
            container.remove();
        }
    }
}

class AdvancedImageConverter {
    constructor() {
        this.currentFile = null;
        this.originalImage = null;
        this.convertedImages = [];
        this.supportedFormats = this.initializeSupportedFormats();
        this.initializeElements();
        this.bindEvents();
        this.updateFormatCounter();
        
        this.multipleHandler = new MultipleImageHandler(this);
        
        this.bindDragDropEvents();
        
        this.convertBtn.addEventListener('click', () => {
            if (this.multipleHandler.selectedFiles.size > 1) {
                this.multipleHandler.convertAllSelected();
            } else {
                this.convertImage();
            }
        });
    }
    // Th√™m v√†o class AdvancedImageConverter

getOriginalFormat(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    return ext === 'jpg' ? 'jpeg' : ext;
}

// C·∫£i thi·ªán thu·∫≠t to√°n ∆∞·ªõc t√≠nh k√≠ch th∆∞·ªõc
estimateConvertedSize(dataUrl) {
    if (dataUrl.startsWith('data:')) {
        const base64Data = dataUrl.split(',')[1];
        return (base64Data.length * 3) / 4; // Ch√≠nh x√°c h∆°n
    }
    return 0;
}

// Method t·ªëi ∆∞u ƒë·ªÉ x·ª≠ l√Ω ·∫£nh nh·ªè
async processSmallImage(file, targetQuality) {
    // ƒê·ªëi v·ªõi ·∫£nh nh·ªè (< 500KB), ch·ªâ thay ƒë·ªïi quality
    if (file.size < 500 * 1024) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = await this.loadImageFromFile(file);
        
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        return new Promise((resolve) => {
            canvas.toBlob((blob) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    resolve({
                        originalFile: file,
                        convertedDataUrl: e.target.result,
                        format: this.getOriginalFormat(file.name),
                        width: img.width,
                        height: img.height,
                        originalSize: file.size,
                        convertedSize: blob.size,
                        sharpenApplied: false
                    });
                };
                reader.readAsDataURL(blob);
            }, this.getMimeType(this.getOriginalFormat(file.name)), targetQuality);
        });
    }
}


fileToDataUrl(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

calculateOptimalQuality(requestedQuality, originalSize, width, height) {
    // T√≠nh to√°n quality d·ª±a tr√™n k√≠ch th∆∞·ªõc ·∫£nh v√† dung l∆∞·ª£ng g·ªëc
    const pixelCount = width * height;
    const bytesPerPixel = originalSize / pixelCount;
    
    // N·∫øu ·∫£nh g·ªëc ƒë√£ ƒë∆∞·ª£c n√©n m·∫°nh, kh√¥ng n√©n th√™m
    if (bytesPerPixel < 1.5) {
        return Math.max(requestedQuality, 0.7); // T·ªëi thi·ªÉu 70%
    }
    
    // N·∫øu ·∫£nh g·ªëc c√≥ dung l∆∞·ª£ng l·ªõn, c√≥ th·ªÉ n√©n m·∫°nh h∆°n
    if (bytesPerPixel > 3) {
        return Math.max(requestedQuality * 0.8, 0.3); // Gi·∫£m 20%
    }
    
    return requestedQuality;
}

applySharpenEffectOptimized(ctx, width, height, amount) {
    // Ch·ªâ l√†m n√©t n·∫øu amount ƒë·ªß l·ªõn ƒë·ªÉ tr√°nh tƒÉng dung l∆∞·ª£ng kh√¥ng c·∫ßn thi·∫øt
    if (amount < 0.1) return;
    
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const sharpenedData = new Uint8ClampedArray(data);
    
    // Kernel l√†m n√©t t·ªëi ∆∞u (√≠t aggressive h∆°n)
    const kernelStrength = Math.min(amount * 0.5, 0.3); // Gi·ªõi h·∫°n strength
    const kernel = [
        0, -kernelStrength, 0,
        -kernelStrength, 1 + 4 * kernelStrength, -kernelStrength,
        0, -kernelStrength, 0
    ];
    
    // Ch·ªâ x·ª≠ l√Ω v√πng c√≥ edge ƒë·ªÉ gi·∫£m noise
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            // Ki·ªÉm tra xem c√≥ ph·∫£i edge kh√¥ng
            if (this.isEdgePixel(data, x, y, width)) {
                for (let c = 0; c < 3; c++) {
                    let sum = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                            const kernelIdx = (ky + 1) * 3 + (kx + 1);
                            sum += data[idx] * kernel[kernelIdx];
                        }
                    }
                    const idx = (y * width + x) * 4 + c;
                    sharpenedData[idx] = Math.max(0, Math.min(255, sum));
                }
            }
        }
    }
    
    const sharpenedImageData = new ImageData(sharpenedData, width, height);
    ctx.putImageData(sharpenedImageData, 0, 0);
}

isEdgePixel(data, x, y, width) {
    const centerIdx = (y * width + x) * 4;
    const threshold = 30; // Ng∆∞·ª°ng ƒë·ªÉ x√°c ƒë·ªãnh edge
    
    // So s√°nh v·ªõi pixel b√™n c·∫°nh
    const rightIdx = (y * width + (x + 1)) * 4;
    const bottomIdx = ((y + 1) * width + x) * 4;
    
    const diffRight = Math.abs(data[centerIdx] - data[rightIdx]) +
                     Math.abs(data[centerIdx + 1] - data[rightIdx + 1]) +
                     Math.abs(data[centerIdx + 2] - data[rightIdx + 2]);
    
    const diffBottom = Math.abs(data[centerIdx] - data[bottomIdx]) +
                      Math.abs(data[centerIdx + 1] - data[bottomIdx + 1]) +
                      Math.abs(data[centerIdx + 2] - data[bottomIdx + 2]);
    
    return diffRight > threshold || diffBottom > threshold;
}
applySharpenEffect(ctx, width, height, amount) {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const sharpenedData = new Uint8ClampedArray(data);
    
    // Kernel l√†m n√©t (Unsharp Mask)
    const kernel = [
        0, -amount, 0,
        -amount, 1 + 4 * amount, -amount,
        0, -amount, 0
    ];
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            for (let c = 0; c < 3; c++) { // RGB channels only
                let sum = 0;
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                        const kernelIdx = (ky + 1) * 3 + (kx + 1);
                        sum += data[idx] * kernel[kernelIdx];
                    }
                }
                const idx = (y * width + x) * 4 + c;
                sharpenedData[idx] = Math.max(0, Math.min(255, sum));
            }
        }
    }
    
    const sharpenedImageData = new ImageData(sharpenedData, width, height);
    ctx.putImageData(sharpenedImageData, 0, 0);
}

    bindDragDropEvents() {
        const uploadArea = document.getElementById('uploadArea');
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                if (this.multipleHandler && this.multipleHandler.uploadMode === 'single') {
                    this.processFile(files[0]);
                } else if (this.multipleHandler) {
                    this.multipleHandler.addFiles(Array.from(files));
                }
            }
        });
    }

    initializeSupportedFormats() {
        return {
            'jpg': { mime: 'image/jpeg', name: 'JPEG', category: 'popular' },
            'jpeg': { mime: 'image/jpeg', name: 'JPEG', category: 'popular' },
            'png': { mime: 'image/png', name: 'PNG', category: 'popular' },
            'gif': { mime: 'image/gif', name: 'GIF', category: 'popular' },
            'webp': { mime: 'image/webp', name: 'WebP', category: 'modern' },
            'bmp': { mime: 'image/bmp', name: 'BMP', category: 'professional' },
            'tiff': { mime: 'image/tiff', name: 'TIFF', category: 'professional' },
            'avif': { mime: 'image/avif', name: 'AVIF', category: 'modern' },
            'heic': { mime: 'image/heic', name: 'HEIC', category: 'modern' },
            'ico': { mime: 'image/x-icon', name: 'ICO', category: 'system' },
            'svg': { mime: 'image/svg+xml', name: 'SVG', category: 'vector' }
        };
    }

    updateFormatCounter() {
        const count = Object.keys(this.supportedFormats).length;
        document.getElementById('supportedFormats').textContent = `${count}+`;
    }

    initializeElements() {
        this.conversionSection = document.getElementById('conversionSection');
        this.qualitySlider = document.getElementById('qualitySlider');
        this.qualityValue = document.getElementById('qualityValue');
        this.resizeEnabled = document.getElementById('resizeEnabled');
        this.resizeInputs = document.getElementById('resizeInputs');
        this.widthInput = document.getElementById('widthInput');
        this.heightInput = document.getElementById('heightInput');
        this.maintainRatio = document.getElementById('maintainRatio');
        this.convertBtn = document.getElementById('convertBtn');
        
        this.previewSection = document.getElementById('previewSection');
        this.previewImage = document.getElementById('previewImage');
        this.fileName = document.getElementById('fileName');
        this.fileSize = document.getElementById('fileSize');
        this.fileDimensions = document.getElementById('fileDimensions');
        
        this.downloadSection = document.getElementById('downloadSection');
        this.convertedImage = document.getElementById('convertedImage');
        this.outputFormat = document.getElementById('outputFormat');
        this.outputDimensions = document.getElementById('outputDimensions');
        this.originalSize = document.getElementById('originalSize');
        this.newSize = document.getElementById('newSize');
        this.compressionRatio = document.getElementById('compressionRatio');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.downloadAllBtn = document.getElementById('downloadAllBtn');
        this.resetBtn = document.getElementById('resetBtn');
        this.sharpenEnabled = document.getElementById('sharpenEnabled');
        this.sharpenControl = document.getElementById('sharpenControl');
        this.sharpenSlider = document.getElementById('sharpenSlider');
        this.sharpenValue = document.getElementById('sharpenValue');
    }

    bindEvents() {
        
        // Th√™m v√†o method bindEvents()
this.qualitySlider.addEventListener('input', (e) => {
    this.qualityValue.textContent = e.target.value;
    
    // Hi·ªÉn th·ªã c·∫£nh b√°o khi quality th·∫•p
    const qualityWarning = document.getElementById('qualityWarning');
    if (parseInt(e.target.value) < 30) {
        qualityWarning.style.display = 'block';
        qualityWarning.className = 'quality-warning error';
        qualityWarning.innerHTML = 'üö® <strong>C·∫£nh b√°o:</strong> Quality qu√° th·∫•p c√≥ th·ªÉ t·∫°o file l·ªõn h∆°n ·∫£nh g·ªëc. Khuy·∫øn ngh·ªã ‚â• 30%.';
    } else if (parseInt(e.target.value) < 50) {
        qualityWarning.style.display = 'block';
        qualityWarning.className = 'quality-warning';
        qualityWarning.innerHTML = '‚ö†Ô∏è <strong>L∆∞u √Ω:</strong> Quality th·∫•p c√≥ th·ªÉ kh√¥ng gi·∫£m dung l∆∞·ª£ng nh∆∞ mong ƒë·ª£i.';
    } else {
        qualityWarning.style.display = 'none';
    }
});

        
        this.downloadAllBtn.addEventListener('click', () => {
            console.log('Download All clicked');
            if (this.multipleHandler) {
                this.multipleHandler.downloadAllImages();
            }
        });
        
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const quality = e.target.dataset.quality;
                this.qualitySlider.value = quality;
                this.qualityValue.textContent = quality;
            });
        });
        
        document.querySelectorAll('.size-preset').forEach(btn => {
            btn.addEventListener('click', (e) => {
                this.widthInput.value = e.target.dataset.width;
                this.heightInput.value = e.target.dataset.height;
                this.resizeEnabled.checked = true;
                this.resizeInputs.style.display = 'block';
            });
        });
        
        this.resizeEnabled.addEventListener('change', (e) => {
            this.resizeInputs.style.display = e.target.checked ? 'block' : 'none';
        });
        
        this.widthInput.addEventListener('input', () => this.handleDimensionChange('width'));
        this.heightInput.addEventListener('input', () => this.handleDimensionChange('height'));
        
        this.downloadBtn.addEventListener('click', () => this.downloadImage());
        this.resetBtn.addEventListener('click', () => this.resetConverter());
         // Sharpen controls
    // Sharpen controls - S·ª¨A L·∫†I
this.sharpenEnabled.addEventListener('change', (e) => {
    const isChecked = e.target.checked;
    const sharpenControl = this.sharpenControl;
    
    if (isChecked) {
        // Hi·ªÉn th·ªã v·ªõi animation
        sharpenControl.style.display = 'block';
        sharpenControl.classList.add('show');
        
        // Scroll smooth ƒë·∫øn ph·∫ßn sharpen
        setTimeout(() => {
            sharpenControl.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'nearest' 
            });
        }, 100);
    } else {
        // ·∫®n v·ªõi animation
        sharpenControl.classList.remove('show');
        setTimeout(() => {
            sharpenControl.style.display = 'none';
        }, 300);
    }
});

this.sharpenSlider.addEventListener('input', (e) => {
    this.sharpenValue.textContent = e.target.value;
});

// Sharpen presets
document.querySelectorAll('.sharpen-preset').forEach(btn => {
    btn.addEventListener('click', (e) => {
        const sharpen = e.target.dataset.sharpen;
        this.sharpenSlider.value = sharpen;
        this.sharpenValue.textContent = sharpen;
        
        // T·ª± ƒë·ªông b·∫≠t sharpen khi ch·ªçn preset
        this.sharpenEnabled.checked = true;
        this.sharpenControl.style.display = 'block';
        this.sharpenControl.classList.add('show');
    });
});

    }

    processFile(file) {
        if (!this.validateImageFile(file)) {
            alert('File kh√¥ng h·ª£p l·ªá!');
            return;
        }

        this.currentFile = file;
        this.displayFileInfo(file);
        this.loadImagePreview(file);
    }

    validateImageFile(file) {
        const maxSize = 100 * 1024 * 1024;
        const allowedTypes = Object.keys(this.supportedFormats);
        const fileExt = file.name.split('.').pop().toLowerCase();
        
        if (file.size > maxSize) {
            alert('File qu√° l·ªõn. K√≠ch th∆∞·ªõc t·ªëi ƒëa l√† 100MB.');
            return false;
        }
        
        if (!file.type.startsWith('image/') && !allowedTypes.includes(fileExt)) {
            alert('ƒê·ªãnh d·∫°ng file kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.');
            return false;
        }
        
        return true;
    }

    isRawFormat(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const rawFormats = ['raw', 'dng', 'cr2', 'cr3', 'nef', 'arw', 'orf'];
        return rawFormats.includes(ext);
    }

    displayFileInfo(file) {
        this.fileName.textContent = file.name;
        this.fileSize.textContent = this.formatFileSize(file.size);
        
        this.previewSection.style.display = 'block';
        this.conversionSection.style.display = 'block';
        this.downloadSection.style.display = 'none';
    }

    loadImagePreview(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.previewImage.src = e.target.result;
            this.previewImage.onload = () => {
                this.originalImage = this.previewImage;
                const dimensions = `${this.previewImage.naturalWidth} √ó ${this.previewImage.naturalHeight}`;
                this.fileDimensions.textContent = dimensions;
                
                this.widthInput.value = this.previewImage.naturalWidth;
                this.heightInput.value = this.previewImage.naturalHeight;
            };
        };
        reader.readAsDataURL(file);
    }

    handleDimensionChange(changedDimension) {
        if (!this.maintainRatio.checked || !this.originalImage) return;
        
        const aspectRatio = this.originalImage.naturalWidth / this.originalImage.naturalHeight;
        
        if (changedDimension === 'width') {
            const newWidth = parseInt(this.widthInput.value);
            if (newWidth) {
                this.heightInput.value = Math.round(newWidth / aspectRatio);
            }
        } else {
            const newHeight = parseInt(this.heightInput.value);
            if (newHeight) {
                this.widthInput.value = Math.round(newHeight * aspectRatio);
            }
        }
    }

    async convertImage() {
        if (!this.currentFile || !this.originalImage) {
            alert('Vui l√≤ng ch·ªçn ·∫£nh tr∆∞·ªõc khi chuy·ªÉn ƒë·ªïi!');
            return;
        }

        this.convertBtn.classList.add('loading');
        this.convertBtn.innerHTML = '<span>üîÑ ƒêang chuy·ªÉn ƒë·ªïi...</span>';

        try {
            const result = await this.processImageConversion(this.currentFile, this.originalImage);
            this.displayConversionResult(result);
        } catch (error) {
            console.error('Conversion error:', error);
            alert('C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh chuy·ªÉn ƒë·ªïi!');
        } finally {
            this.convertBtn.classList.remove('loading');
            this.convertBtn.innerHTML = '<span>üîÑ Chuy·ªÉn ƒë·ªïi ·∫£nh</span>';
        }
    }

    async processImageConversion(file, img) {
    const format = document.querySelector('input[name="format"]:checked').value;
    const quality = parseInt(this.qualitySlider.value) / 100;
    const sharpenEnabled = this.sharpenEnabled.checked;
    const sharpenAmount = parseInt(this.sharpenSlider.value) / 100;
    
    let width = img.naturalWidth || img.width;
    let height = img.naturalHeight || img.height;
    
    // QUAN TR·ªåNG: Ki·ªÉm tra xem c√≥ c·∫ßn x·ª≠ l√Ω kh√¥ng
    const needsProcessing = this.resizeEnabled.checked || 
                           sharpenEnabled || 
                           format !== this.getOriginalFormat(file.name) ||
                           quality < 0.9; // Ch·ªâ x·ª≠ l√Ω khi quality < 90%
    
    // N·∫øu kh√¥ng c·∫ßn x·ª≠ l√Ω, tr·∫£ v·ªÅ file g·ªëc
    if (!needsProcessing) {
        const originalDataUrl = await this.fileToDataUrl(file);
        return {
            originalFile: file,
            convertedDataUrl: originalDataUrl,
            format: this.getOriginalFormat(file.name),
            width: width,
            height: height,
            originalSize: file.size,
            convertedSize: file.size,
            sharpenApplied: false
        };
    }
    
    if (this.resizeEnabled.checked) {
        width = parseInt(this.widthInput.value) || width;
        height = parseInt(this.heightInput.value) || height;
    }

    // S·ª≠ d·ª•ng toBlob() thay v√¨ toDataURL() ƒë·ªÉ gi·∫£m dung l∆∞·ª£ng
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = width;
        canvas.height = height;
        
        // T·ªëi ∆∞u rendering
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        ctx.drawImage(img, 0, 0, width, height);
        
        // √Åp d·ª•ng sharpen n·∫øu c·∫ßn
        if (sharpenEnabled && sharpenAmount > 0.1) {
            this.applySharpenEffectOptimized(ctx, width, height, sharpenAmount);
        }
        
        // S·ª≠ d·ª•ng toBlob() thay v√¨ toDataURL()
        const mimeType = this.getMimeType(format);
        canvas.toBlob((blob) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                resolve({
                    originalFile: file,
                    convertedDataUrl: e.target.result,
                    format: format,
                    width: width,
                    height: height,
                    originalSize: file.size,
                    convertedSize: blob.size,
                    sharpenApplied: sharpenEnabled
                });
            };
            reader.readAsDataURL(blob);
        }, mimeType, quality);
    });
}

    loadImageFromFile(file) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const reader = new FileReader();
            
            reader.onload = (e) => {
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    displayConversionResult(result) {
        this.convertedImage.src = result.convertedDataUrl;
        this.convertedDataUrl = result.convertedDataUrl;
        this.convertedFormat = result.format;
        
        this.outputFormat.textContent = result.format.toUpperCase();
        this.outputDimensions.textContent = `${result.width} √ó ${result.height}`;
        this.originalSize.textContent = this.formatFileSize(result.originalSize);
        this.newSize.textContent = this.formatFileSize(result.convertedSize);
        
        const compressionRatio = ((result.originalSize - result.convertedSize) / result.originalSize * 100);
        this.compressionRatio.textContent = compressionRatio > 0 ? 
            `Gi·∫£m ${compressionRatio.toFixed(1)}%` : 
            `TƒÉng ${Math.abs(compressionRatio).toFixed(1)}%`;
        
        this.downloadSection.style.display = 'block';
        this.downloadSection.scrollIntoView({ behavior: 'smooth' });
    }

    displayBatchResults() {
        if (this.convertedImages.length === 0) {
            console.log('No converted images to display');
            return;
        }
        
        const firstResult = this.convertedImages[0];
        this.convertedImage.src = firstResult.convertedDataUrl;
        
        const totalOriginalSize = this.convertedImages.reduce((sum, img) => sum + img.originalSize, 0);
        const totalConvertedSize = this.convertedImages.reduce((sum, img) => sum + img.convertedSize, 0);
        const avgCompression = ((totalOriginalSize - totalConvertedSize) / totalOriginalSize * 100);
        
        this.outputFormat.textContent = `${firstResult.format.toUpperCase()} (${this.convertedImages.length} ·∫£nh)`;
        this.outputDimensions.textContent = 'Nhi·ªÅu k√≠ch th∆∞·ªõc';
        this.originalSize.textContent = this.formatFileSize(totalOriginalSize);
        this.newSize.textContent = this.formatFileSize(totalConvertedSize);
        this.compressionRatio.textContent = avgCompression > 0 ? 
            `Gi·∫£m ${avgCompression.toFixed(1)}%` : 
            `TƒÉng ${Math.abs(avgCompression).toFixed(1)}%`;
        
        this.downloadSection.style.display = 'block';
        this.downloadAllBtn.style.display = 'inline-block';
        this.downloadBtn.style.display = 'none';
        this.downloadSection.scrollIntoView({ behavior: 'smooth' });
        
        console.log(`Batch results displayed: ${this.convertedImages.length} images`);
    }

    downloadImage() {
    if (!this.convertedDataUrl) return;
    
    // T√™n file lu√¥n l√† "dvnt"
    const fileName = `dvnt.${this.convertedFormat}`;
    const link = document.createElement('a');
    link.download = fileName;
    link.href = this.convertedDataUrl;
    link.click();
}


    resetConverter() {
    this.previewSection.style.display = 'none';
    this.conversionSection.style.display = 'none';
    this.downloadSection.style.display = 'none';
    
    this.qualitySlider.value = 90;
    this.qualityValue.textContent = '90';
    this.resizeEnabled.checked = false;
    this.resizeInputs.style.display = 'none';
    
    // Reset sharpen settings - TH√äM NH·ªÆNG D√íNG N√ÄY
    this.sharpenEnabled.checked = false;
    this.sharpenControl.style.display = 'none';
    this.sharpenControl.classList.remove('show');
    this.sharpenSlider.value = 30;
    this.sharpenValue.textContent = '30';
    
    document.querySelector('input[name="format"][value="png"]').checked = true;
    
    this.currentFile = null;
    this.originalImage = null;
    this.convertedDataUrl = null;
    this.convertedFormat = null;
    this.convertedImages = [];
}


    getMimeType(format) {
        const formatInfo = this.supportedFormats[format];
        if (formatInfo) {
            return formatInfo.mime;
        }
        
        const mimeTypes = {
            'png': 'image/png',
            'jpeg': 'image/jpeg',
            'jpg': 'image/jpeg',
            'webp': 'image/webp',
            'gif': 'image/gif',
            'bmp': 'image/bmp',
            'tiff': 'image/tiff'
        };
        return mimeTypes[format] || 'image/png';
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    estimateConvertedSize(dataUrl) {
        const base64Length = dataUrl.split(',')[1].length;
        const sizeInBytes = (base64Length * 3) / 4;
        return sizeInBytes;
    }
}

let multipleHandler;

document.addEventListener('DOMContentLoaded', () => {
    const converter = new AdvancedImageConverter();
    multipleHandler = converter.multipleHandler;
    
    const toggleFormats = document.getElementById('toggleFormats');
    if (toggleFormats) {
        toggleFormats.addEventListener('click', () => {
            const formatsList = document.getElementById('formatsList');
            const isVisible = formatsList.style.display !== 'none';
            formatsList.style.display = isVisible ? 'none' : 'block';
            toggleFormats.textContent = isVisible ? 
                'üìã Xem t·∫•t c·∫£ ƒë·ªãnh d·∫°ng h·ªó tr·ª£' : 
                'üìã ·∫®n danh s√°ch ƒë·ªãnh d·∫°ng';
        });
    }
});


// Utility functions
class ImageUtils {
    static async compressImage(file, quality = 0.8, maxWidth = 1920, maxHeight = 1080) {
        return new Promise((resolve) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = () => {
                let { width, height } = img;
                
                // Calculate new dimensions
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                ctx.drawImage(img, 0, 0, width, height);
                canvas.toBlob(resolve, 'image/jpeg', quality);
            };
            
            img.src = URL.createObjectURL(file);
        });
    }

    static detectImageFormat(arrayBuffer) {
        const uint8Array = new Uint8Array(arrayBuffer);
        
        // JPEG
        if (uint8Array[0] === 0xFF && uint8Array[1] === 0xD8) {
            return 'jpeg';
        }
        
        // PNG
        if (uint8Array[0] === 0x89 && uint8Array[1] === 0x50 && 
            uint8Array[2] === 0x4E && uint8Array[3] === 0x47) {
            return 'png';
        }
        
        // GIF
        if (uint8Array[0] === 0x47 && uint8Array[1] === 0x49 && uint8Array[2] === 0x46) {
            return 'gif';
        }
        
        // WebP
        if (uint8Array[8] === 0x57 && uint8Array[9] === 0x45 && 
            uint8Array[10] === 0x42 && uint8Array[11] === 0x50) {
            return 'webp';
        }
        
        // BMP
        if (uint8Array[0] === 0x42 && uint8Array[1] === 0x4D) {
            return 'bmp';
        }
        
        return 'unknown';
    }

    static async createImageFromBlob(blob) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                URL.revokeObjectURL(img.src);
                resolve(img);
            };
            img.onerror = reject;
            img.src = URL.createObjectURL(blob);
        });
    }
}

// Service Worker for offline functionality (optional)
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
            .then((registration) => {
                console.log('SW registered: ', registration);
            })
            .catch((registrationError) => {
                console.log('SW registration failed: ', registrationError);
            });
    });
}


    </script>
    
</body>
</html>
