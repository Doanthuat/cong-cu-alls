<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./asset/css/style.css">
    <title>C√¥ng c·ª• t·∫£i ·∫£nh t·ªëi ∆∞u</title>
</head>
<style>
    .stat-item, 
    .stat-label {
        color: #fff;
            background-color: transparent !important;
            box-shadow:none !important;
    }
</style>
<header class="doitenhinhanhsticky__header" id="doitenhinhanhsticky__header">
        <!-- render header -->
    </header>
    <!-- ƒêo·∫°n scrip render header -->
    <script>
        fetch('./templates/header.html')
            .then(response => response.text())
            .then(data => {
                document.querySelector("#doitenhinhanhsticky__header").innerHTML = data;
            })
            .catch(error => console.error('L·ªói:', error));
    </script>
<body style="padding-top:100px;">
    
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>üîß C√¥ng c·ª• t·∫£i ·∫£nh t·ªëi ∆∞u</h1>
                <p>T·∫£i ·∫£nh v·ªõi x·ª≠ l√Ω l·ªói th√¥ng minh v√† retry t·ª± ƒë·ªông</p>
                <div class="header-stats">
                    <div class="stat-item">
                        <div class="stat-number" id="imageCountStat">0</div>
                        <div class="stat-label">·∫¢nh ƒë∆∞·ª£c t·∫£i</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="successCountStat">0</div>
                        <div class="stat-label">Th√†nh c√¥ng</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="failedCountStat">0</div>
                        <div class="stat-label">Th·∫•t b·∫°i</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="content">
            <!-- T√≠nh nƒÉng n·ªïi b·∫≠t -->
            <div class="features">
                <div class="features-grid">
                    <div class="feature-item">
                        <div class="feature-icon">üîÑ</div>
                        <div>
                            <strong>Retry t·ª± ƒë·ªông</strong><br>
                            <small>Th·ª≠ l·∫°i link l·ªói v·ªõi nhi·ªÅu ph∆∞∆°ng ph√°p</small>
                        </div>
                    </div>
                    <div class="feature-item">
                        <div class="feature-icon">üõ°Ô∏è</div>
                        <div>
                            <strong>Bypass CORS</strong><br>
                            <small>X·ª≠ l√Ω link b·ªã ch·∫∑n CORS policy</small>
                        </div>
                    </div>
                    <div class="feature-item">
                        <div class="feature-icon">‚è±Ô∏è</div>
                        <div>
                            <strong>Timeout th√¥ng minh</strong><br>
                            <small>T·ª± ƒë·ªông skip link t·∫£i ch·∫≠m</small>
                        </div>
                    </div>
                    <div class="feature-item">
                        <div class="feature-icon">üìä</div>
                        <div>
                            <strong>B√°o c√°o chi ti·∫øt</strong><br>
                            <small>Hi·ªÉn th·ªã link th√†nh c√¥ng/th·∫•t b·∫°i</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Nh·∫≠p link ·∫£nh -->
            <div class="section">
                <div class="section-title">
                    <div class="section-icon">üîó</div>
                    Nh·∫≠p link ·∫£nh
                </div>
                <textarea 
                    id="imageUrls" 
                    placeholder="D√°n c√°c link ·∫£nh v√†o ƒë√¢y, m·ªói link m·ªôt d√≤ng:&#10;&#10;V√≠ d·ª•:&#10;https://example.com/image1.jpg&#10;https://example.com/image2.png&#10;https://example.com/image3.webp&#10;&#10;üí° Tip: C√¥ng c·ª• s·∫Ω t·ª± ƒë·ªông th·ª≠ nhi·ªÅu c√°ch ƒë·ªÉ t·∫£i nh·ªØng link kh√≥ khƒÉn!"
                    oninput="updateImageCounter()"
                ></textarea>
                <div class="image-counter" id="imageCounter">
                    <div class="counter-icon">üìä</div>
                    <span>S·ªë l∆∞·ª£ng ·∫£nh: 0</span>
                </div>
            </div>

            <!-- Ch·ªçn ƒë·ªãnh d·∫°ng -->
            <div class="section">
                <div class="section-title">
                    <div class="section-icon">üéØ</div>
                    Ch·ªçn ƒë·ªãnh d·∫°ng xu·∫•t
                </div>
                <div class="format-grid">
                    <div class="format-option selected" data-format="original">
                        <input type="radio" name="format" value="original" checked>
                        <div class="format-emoji">üìã</div>
                        <div class="format-label">Gi·ªØ nguy√™n</div>
                        <div class="format-desc">ƒê·ªãnh d·∫°ng g·ªëc</div>
                    </div>
                    <div class="format-option" data-format="jpg">
                        <input type="radio" name="format" value="jpg">
                        <div class="format-emoji">üì∑</div>
                        <div class="format-label">JPG</div>
                        <div class="format-desc">N√©n c√≥ m·∫•t ch·∫•t l∆∞·ª£ng</div>
                    </div>
                    <div class="format-option" data-format="png">
                        <input type="radio" name="format" value="png">
                        <div class="format-emoji">üñºÔ∏è</div>
                        <div class="format-label">PNG</div>
                        <div class="format-desc">N√©n kh√¥ng m·∫•t ch·∫•t l∆∞·ª£ng</div>
                    </div>
                    <div class="format-option" data-format="webp">
                        <input type="radio" name="format" value="webp">
                        <div class="format-emoji">üåê</div>
                        <div class="format-label">WebP</div>
                        <div class="format-desc">Hi·ªán ƒë·∫°i, dung l∆∞·ª£ng nh·ªè</div>
                    </div>
                    <div class="format-option" data-format="bmp">
                        <input type="radio" name="format" value="bmp">
                        <div class="format-emoji">üé®</div>
                        <div class="format-label">BMP</div>
                        <div class="format-desc">Kh√¥ng n√©n</div>
                    </div>
                    <div class="format-option" data-format="gif">
                        <input type="radio" name="format" value="gif">
                        <div class="format-emoji">üé¨</div>
                        <div class="format-label">GIF</div>
                        <div class="format-desc">H·ªó tr·ª£ animation</div>
                    </div>
                    <div class="format-option" data-format="tiff">
                        <input type="radio" name="format" value="tiff">
                        <div class="format-emoji">üìê</div>
                        <div class="format-label">TIFF</div>
                        <div class="format-desc">Ch·∫•t l∆∞·ª£ng cao</div>
                    </div>
                    <div class="format-option" data-format="ico">
                        <input type="radio" name="format" value="ico">
                        <div class="format-emoji">‚öôÔ∏è</div>
                        <div class="format-label">ICO</div>
                        <div class="format-desc">Icon Windows</div>
                    </div>
                </div>
            </div>

            <!-- N√∫t ch·ª©c nƒÉng -->
            <div class="section">
                <div class="section-title">
                    <div class="section-icon">üöÄ</div>
                    H√†nh ƒë·ªông
                </div>
                <div class="action-buttons">
                    <button class="btn btn-preview" onclick="previewImages()">
                        <span class="btn-icon">üëÅÔ∏è</span>
                        <span>Xem tr∆∞·ªõc ·∫£nh</span>
                    </button>
                    <button class="btn btn-download-single" onclick="downloadImagesIndividually()">
                        <span class="btn-icon">üì•</span>
                        <span>T·∫£i t·ª´ng ·∫£nh ri√™ng</span>
                    </button>
                    <button class="btn btn-download-zip" id="zipButton" onclick="downloadImagesAsZip()">
                        <span class="btn-icon">üóúÔ∏è</span>
                        <span>T·∫£i ·∫£nh n√©n (ZIP)</span>
                    </button>
                    <button class="btn btn-clear" onclick="clearAll()">
                        <span class="btn-icon">üóëÔ∏è</span>
                        <span>X√≥a t·∫•t c·∫£</span>
                    </button>
                </div>
            </div>

            <!-- Progress bar -->
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">ƒêang t·∫£i... 0%</div>
            </div>

            <!-- Status -->
            <div class="status" id="status"></div>

            <!-- Error Report -->
            <div class="error-report" id="errorReport">
                <div class="error-title">‚ö†Ô∏è Link kh√¥ng t·∫£i ƒë∆∞·ª£c:</div>
                <ul class="error-list" id="errorList"></ul>
            </div>

            <!-- Retry Section -->
            <div class="retry-section" id="retrySection">
                <div class="retry-title">üîÑ Th·ª≠ l·∫°i link th·∫•t b·∫°i:</div>
                <div class="retry-list" id="retryList"></div>
            </div>

            <!-- Preview container -->
            <div class="preview-container" id="previewContainer">
                <div class="preview-title">
                    <span class="btn-icon">üñºÔ∏è</span>
                    Xem tr∆∞·ªõc ·∫£nh
                </div>
                <div class="image-preview" id="imagePreview"></div>
            </div>
        </div>
    </div>
    <!-- Footer -->
    <footer class="dvnt-footer" id="dvnt-footer"></footer>
        <script>
        fetch('./templates/footer.html')
            .then(response => response.text())
            .then(data => {
                document.querySelector("#dvnt-footer").innerHTML = data;
            })
            .catch(error => console.error('L·ªói:', error));
    </script>
    <!-- JSZip library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Global variables
        let failedUrls = [];
        let successCount = 0;
        let failedCount = 0;

        // X·ª≠ l√Ω ch·ªçn ƒë·ªãnh d·∫°ng
        document.querySelectorAll('.format-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.format-option').forEach(opt => opt.classList.remove('selected'));
                this.classList.add('selected');
                this.querySelector('input[type="radio"]').checked = true;
            });
        });

        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ·∫£nh v√† hi·ªÉn th·ªã n√∫t ZIP
        function updateImageCounter() {
            const urls = getImageUrls();
            const counter = document.getElementById('imageCounter');
            const zipButton = document.getElementById('zipButton');
            const statCounter = document.getElementById('imageCountStat');
            
            counter.innerHTML = `
                <div class="counter-icon">üìä</div>
                <span>S·ªë l∆∞·ª£ng ·∫£nh: ${urls.length}</span>
            `;
            statCounter.textContent = urls.length;
            
            if (urls.length >= 2) {
                zipButton.style.display = 'flex';
                zipButton.classList.remove('btn-disabled');
            } else {
                zipButton.style.display = 'none';
            }
        }

        // C·∫≠p nh·∫≠t th·ªëng k√™
        function updateStats() {
            document.getElementById('successCountStat').textContent = successCount;
            document.getElementById('failedCountStat').textContent = failedCount;
        }

        // H√†m t·ªëi ∆∞u ƒë·ªÉ t·∫£i ·∫£nh v·ªõi nhi·ªÅu ph∆∞∆°ng ph√°p
        async function downloadImageOptimized(url, format, retryCount = 0) {
            const maxRetries = 3;
            const timeout = 10000; // 10 seconds timeout
            
            // Danh s√°ch c√°c proxy/CORS bypass methods
            const corsProxies = [
                '', // Original URL
                'https://cors-anywhere.herokuapp.com/',
                'https://api.allorigins.win/raw?url=',
                'https://proxy.cors.sh/',
            ];

            for (let proxyIndex = 0; proxyIndex < corsProxies.length; proxyIndex++) {
                const proxyUrl = corsProxies[proxyIndex] + encodeURIComponent(url);
                const actualUrl = proxyIndex === 0 ? url : proxyUrl;

                try {
                    // T·∫°o AbortController cho timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);

                    const response = await fetch(actualUrl, {
                        method: 'GET',
                        mode: proxyIndex === 0 ? 'cors' : 'cors',
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                            'Referer': 'https://www.google.com/',
                            'Accept': 'image/*,*/*;q=0.8',
                        },
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    // Ki·ªÉm tra content-type
                    const contentType = response.headers.get('content-type');
                    if (contentType && !contentType.startsWith('image/')) {
                        throw new Error('Kh√¥ng ph·∫£i file ·∫£nh h·ª£p l·ªá');
                    }

                    const blob = await response.blob();
                    
                    // Ki·ªÉm tra k√≠ch th∆∞·ªõc blob
                    if (blob.size === 0) {
                        throw new Error('File ·∫£nh r·ªóng');
                    }

                    // T·∫£i ·∫£nh th√†nh c√¥ng
                    if (format === 'original') {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = getFileName(url);
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                    } else {
                        const convertedBlob = await convertImageFormat(blob, format);
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(convertedBlob);
                        link.download = getFileName(url, format);
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                    }

                    return { success: true, url: url };

                } catch (error) {
                    console.log(`Ph∆∞∆°ng ph√°p ${proxyIndex + 1} th·∫•t b·∫°i cho ${url}:`, error.message);
                    
                    // N·∫øu ƒë√¢y l√† l·∫ßn th·ª≠ cu·ªëi c√πng v·ªõi proxy cu·ªëi c√πng
                    if (proxyIndex === corsProxies.length - 1) {
                        if (retryCount < maxRetries) {
                            // Th·ª≠ l·∫°i sau delay
                            await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
                            return await downloadImageOptimized(url, format, retryCount + 1);
                        } else {
                            // Th·∫•t b·∫°i ho√†n to√†n
                            throw new Error(`T·∫•t c·∫£ ph∆∞∆°ng ph√°p ƒë·ªÅu th·∫•t b·∫°i: ${error.message}`);
                        }
                    }
                }
            }
        }

        // H√†m xem tr∆∞·ªõc ·∫£nh v·ªõi x·ª≠ l√Ω l·ªói t·ªët h∆°n
        async function previewImages() {
            const urls = getImageUrls();
            if (urls.length === 0) {
                showStatus('Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt link ·∫£nh!', 'error');
                return;
            }

            const previewContainer = document.getElementById('previewContainer');
            const imagePreview = document.getElementById('imagePreview');
            
            previewContainer.style.display = 'block';
            imagePreview.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="loading"></div><br><br>ƒêang ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa ·∫£nh...</div>';

            const validImages = [];
            const invalidImages = [];

            for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                try {
                    // Th·ª≠ HEAD request tr∆∞·ªõc
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);

                    const response = await fetch(url, { 
                        method: 'HEAD',
                        signal: controller.signal,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        }
                    });

                    clearTimeout(timeoutId);

                    if (response.ok) {
                        const contentType = response.headers.get('content-type');
                        if (contentType && contentType.startsWith('image/')) {
                            validImages.push({
                                url: url,
                                name: getFileName(url),
                                size: response.headers.get('content-length') || 'Kh√¥ng x√°c ƒë·ªãnh',
                                status: 'success'
                            });
                        } else {
                            invalidImages.push({ url, reason: 'Kh√¥ng ph·∫£i file ·∫£nh' });
                        }
                    } else {
                        invalidImages.push({ url, reason: `HTTP ${response.status}` });
                    }
                } catch (error) {
                    // N·∫øu HEAD request th·∫•t b·∫°i, v·∫´n th√™m v√†o danh s√°ch nh∆∞ng ƒë√°nh d·∫•u c·∫ßn ki·ªÉm tra
                    validImages.push({
                        url: url,
                        name: getFileName(url),
                        size: 'C·∫ßn ki·ªÉm tra',
                        status: 'warning'
                    });
                }
            }

            if (validImages.length === 0) {
                imagePreview.innerHTML = '<div style="text-align: center; padding: 40px; color: #718096;">‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh h·ª£p l·ªá n√†o!</div>';
                return;
            }

            imagePreview.innerHTML = '';
            validImages.forEach((img, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';
                previewItem.innerHTML = `
                    <img src="${img.url}" alt="·∫¢nh ${index + 1}" 
                         onerror="this.parentElement.querySelector('.preview-status').textContent='L·ªói t·∫£i'; this.parentElement.querySelector('.preview-status').className='preview-status error';"
                         onload="this.parentElement.querySelector('.preview-status').textContent='T·∫£i th√†nh c√¥ng'; this.parentElement.querySelector('.preview-status').className='preview-status success';">
                    <div class="preview-info">
                        <div class="preview-filename">${img.name}</div>
                        <div class="preview-size">
                            <span>üíæ</span>
                            <span>${formatFileSize(img.size)}</span>
                        </div>
                        <div class="preview-status ${img.status}">ƒêang t·∫£i...</div>
                    </div>
                `;
                imagePreview.appendChild(previewItem);
            });

            showStatus(`‚úÖ ƒê√£ ki·ªÉm tra ${validImages.length} ·∫£nh. ${invalidImages.length > 0 ? `${invalidImages.length} link c√≥ v·∫•n ƒë·ªÅ.` : 'T·∫•t c·∫£ link ƒë·ªÅu h·ª£p l·ªá!'}`, 
                      invalidImages.length > 0 ? 'warning' : 'success');

            if (invalidImages.length > 0) {
                showErrorReport(invalidImages);
            }
        }

        // H√†m t·∫£i t·ª´ng ·∫£nh ri√™ng l·∫ª v·ªõi t·ªëi ∆∞u
        async function downloadImagesIndividually() {
            const urls = getImageUrls();
            if (urls.length === 0) {
                showStatus('Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt link ·∫£nh!', 'error');
                return;
            }

            const format = document.querySelector('input[name="format"]:checked').value;
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            progressContainer.style.display = 'block';
            
            successCount = 0;
            failedCount = 0;
            failedUrls = [];

            for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                try {
                    progressText.textContent = `ƒêang t·∫£i ·∫£nh ${i + 1}/${urls.length}... (${url.substring(0, 50)}...)`;
                    
                    await downloadImageOptimized(url, format);
                    successCount++;
                    
                } catch (error) {
                    console.error(`L·ªói t·∫£i ·∫£nh ${url}:`, error);
                    failedCount++;
                    failedUrls.push({ url, error: error.message });
                }

                // C·∫≠p nh·∫≠t progress
                const progress = Math.round(((i + 1) / urls.length) * 100);
                progressFill.style.width = progress + '%';
                updateStats();

                // Delay nh·ªè ƒë·ªÉ tr√°nh spam requests
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            progressContainer.style.display = 'none';
            
            const totalImages = urls.length;
            if (successCount === totalImages) {
                showStatus(`üéâ ƒê√£ t·∫£i th√†nh c√¥ng t·∫•t c·∫£ ${successCount} ·∫£nh!`, 'success');
            } else if (successCount > 0) {
                showStatus(`‚ö†Ô∏è ƒê√£ t·∫£i th√†nh c√¥ng ${successCount}/${totalImages} ·∫£nh. ${failedCount} ·∫£nh th·∫•t b·∫°i.`, 'warning');
                showErrorReport(failedUrls);
                showRetrySection();
            } else {
                showStatus(`‚ùå Kh√¥ng th·ªÉ t·∫£i ·∫£nh n√†o. Vui l√≤ng ki·ªÉm tra l·∫°i c√°c link.`, 'error');
                showErrorReport(failedUrls);
            }
        }

        // H√†m t·∫£i ·∫£nh d·∫°ng ZIP v·ªõi t·ªëi ∆∞u
        async function downloadImagesAsZip() {
            const urls = getImageUrls();
            if (urls.length < 2) {
                showStatus('C·∫ßn √≠t nh·∫•t 2 ·∫£nh ƒë·ªÉ t·∫°o file ZIP!', 'error');
                return;
            }

            const format = document.querySelector('input[name="format"]:checked').value;
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            progressContainer.style.display = 'block';
            progressText.textContent = 'ƒêang chu·∫©n b·ªã t·∫°o file ZIP...';

            try {
                const zip = new JSZip();
                successCount = 0;
                failedCount = 0;
                failedUrls = [];

                for (let i = 0; i < urls.length; i++) {
                    const url = urls[i];
                    try {
                        progressText.textContent = `ƒêang x·ª≠ l√Ω ·∫£nh ${i + 1}/${urls.length} cho ZIP...`;
                        
                        // T·∫£i ·∫£nh b·∫±ng ph∆∞∆°ng ph√°p t·ªëi ∆∞u
                        const response = await fetch(url, {
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });

                        if (!response.ok) throw new Error(`HTTP ${response.status}`);

                        const blob = await response.blob();
                        let finalBlob = blob;
                        let fileName = getFileName(url);

                        if (format !== 'original') {
                            finalBlob = await convertImageFormat(blob, format);
                            fileName = getFileName(url, format);
                        }

                        // Th√™m ·∫£nh v√†o ZIP
                        zip.file(fileName, finalBlob);
                        successCount++;

                    } catch (error) {
                        console.error(`L·ªói x·ª≠ l√Ω ·∫£nh ${url}:`, error);
                        failedCount++;
                        failedUrls.push({ url, error: error.message });
                    }

                    // C·∫≠p nh·∫≠t progress
                    const progress = Math.round((i / urls.length) * 80);
                    progressFill.style.width = progress + '%';
                    updateStats();
                }

                if (successCount === 0) {
                    throw new Error('Kh√¥ng c√≥ ·∫£nh h·ª£p l·ªá n√†o ƒë·ªÉ t·∫°o ZIP');
                }

                // T·∫°o file ZIP
                progressText.textContent = 'ƒêang t·∫°o file ZIP...';
                progressFill.style.width = '90%';

                const zipBlob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: {
                        level: 6
                    }
                });

                // T·∫£i v·ªÅ file ZIP
                const link = document.createElement('a');
                link.href = URL.createObjectURL(zipBlob);
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                link.download = `images_${timestamp}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

                progressFill.style.width = '100%';
                progressText.textContent = 'Ho√†n th√†nh!';

                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);

                if (failedCount === 0) {
                    showStatus(`üéâ ƒê√£ t·∫°o file ZIP th√†nh c√¥ng v·ªõi t·∫•t c·∫£ ${successCount} ·∫£nh!`, 'success');
                } else {
                    showStatus(`‚ö†Ô∏è ƒê√£ t·∫°o file ZIP v·ªõi ${successCount} ·∫£nh. ${failedCount} ·∫£nh kh√¥ng th·ªÉ x·ª≠ l√Ω.`, 'warning');
                    showErrorReport(failedUrls);
                }

            } catch (error) {
                progressContainer.style.display = 'none';
                showStatus(`‚ùå L·ªói t·∫°o file ZIP: ${error.message}`, 'error');
                if (failedUrls.length > 0) {
                    showErrorReport(failedUrls);
                }
            }
        }

        // Hi·ªÉn th·ªã b√°o c√°o l·ªói
        function showErrorReport(errors) {
            const errorReport = document.getElementById('errorReport');
            const errorList = document.getElementById('errorList');
            
            if (errors.length === 0) {
                errorReport.style.display = 'none';
                return;
            }

            errorList.innerHTML = '';
            errors.forEach(error => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${error.url}</strong><br><small>L·ªói: ${error.error || error.reason}</small>`;
                errorList.appendChild(li);
            });

            errorReport.style.display = 'block';
        }

        // Hi·ªÉn th·ªã section retry
        function showRetrySection() {
            if (failedUrls.length === 0) return;

            const retrySection = document.getElementById('retrySection');
            const retryList = document.getElementById('retryList');
            
            retryList.innerHTML = '';
            failedUrls.forEach((failed, index) => {
                const retryItem = document.createElement('div');
                retryItem.className = 'retry-item';
                retryItem.textContent = `Link ${index + 1}`;
                retryItem.onclick = () => retryFailedUrl(failed.url, index);
                retryList.appendChild(retryItem);
            });

            retrySection.style.display = 'block';
        }

        // Th·ª≠ l·∫°i link th·∫•t b·∫°i
        async function retryFailedUrl(url, index) {
            const format = document.querySelector('input[name="format"]:checked').value;
            
            try {
                showStatus(`üîÑ ƒêang th·ª≠ l·∫°i: ${url.substring(0, 50)}...`, 'warning');
                await downloadImageOptimized(url, format);
                
                // X√≥a kh·ªèi danh s√°ch th·∫•t b·∫°i
                failedUrls.splice(index, 1);
                failedCount--;
                successCount++;
                updateStats();
                
                showStatus(`‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng link ƒë√£ th·ª≠ l·∫°i!`, 'success');
                
                // C·∫≠p nh·∫≠t retry section
                if (failedUrls.length === 0) {
                    document.getElementById('retrySection').style.display = 'none';
                } else {
                    showRetrySection();
                }
                
            } catch (error) {
                showStatus(`‚ùå V·∫´n kh√¥ng th·ªÉ t·∫£i: ${error.message}`, 'error');
            }
        }

        // H√†m chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng ·∫£nh (c·∫£i ti·∫øn)
        function convertImageFormat(blob, format) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // X·ª≠ l√Ω n·ªÅn tr·∫Øng cho c√°c ƒë·ªãnh d·∫°ng kh√¥ng h·ªó tr·ª£ trong su·ªët
                    if (format === 'jpg' || format === 'bmp') {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    
                    ctx.drawImage(img, 0, 0);

                    let mimeType, quality;
                    
                    switch(format) {
                        case 'jpg':
                            mimeType = 'image/jpeg';
                            quality = 0.9;
                            break;
                        case 'png':
                            mimeType = 'image/png';
                            break;
                        case 'webp':
                            mimeType = 'image/webp';
                            quality = 0.9;
                            break;
                        case 'bmp':
                            mimeType = 'image/bmp';
                            break;
                        case 'gif':
                            mimeType = 'image/gif';
                            break;
                        case 'tiff':
                            mimeType = 'image/tiff';
                            break;
                        case 'ico':
                            // Resize to common icon size
                            const iconCanvas = document.createElement('canvas');
                            const iconCtx = iconCanvas.getContext('2d');
                            iconCanvas.width = 32;
                            iconCanvas.height = 32;
                            iconCtx.drawImage(canvas, 0, 0, 32, 32);
                            iconCanvas.toBlob(resolve, 'image/x-icon');
                            return;
                        default:
                            mimeType = 'image/png';
                    }

                    canvas.toBlob(resolve, mimeType, quality);
                };

                img.onerror = () => reject(new Error('Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng ·∫£nh'));
                img.src = URL.createObjectURL(blob);
            });
        }

        // H√†m l·∫•y danh s√°ch URL
        function getImageUrls() {
            const textarea = document.getElementById('imageUrls');
            const urls = textarea.value.split('\n')
                .map(url => url.trim())
                .filter(url => url.length > 0);
            return urls;
        }

        // H√†m l·∫•y t√™n file (c·∫£i ti·∫øn)
        function getFileName(url, newFormat = null) {
            const urlParts = url.split('/');
            let fileName = urlParts[urlParts.length - 1];
            
            // Lo·∫°i b·ªè query parameters
            fileName = fileName.split('?')[0];
            
            if (newFormat) {
                const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "") || 'image';
                return `${nameWithoutExt}.${newFormat}`;
            }
            
            // N·∫øu kh√¥ng c√≥ ƒëu√¥i file, th√™m .jpg
            if (!fileName.includes('.')) {
                fileName += '.jpg';
            }
            
            return fileName;
        }

        // H√†m format k√≠ch th∆∞·ªõc file
        function formatFileSize(bytes) {
            if (bytes === 'Kh√¥ng x√°c ƒë·ªãnh' || bytes === 'C·∫ßn ki·ªÉm tra') return bytes;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            if (bytes === 0) return '0 Byte';
            const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
        }

        // H√†m hi·ªÉn th·ªã tr·∫°ng th√°i
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 8000);
        }

        // H√†m x√≥a t·∫•t c·∫£
        function clearAll() {
            document.getElementById('imageUrls').value = '';
            document.getElementById('previewContainer').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('status').style.display = 'none';
            document.getElementById('errorReport').style.display = 'none';
            document.getElementById('retrySection').style.display = 'none';
            
            successCount = 0;
            failedCount = 0;
            failedUrls = [];
            
            updateImageCounter();
            updateStats();
            showStatus('‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu!', 'success');
        }

        // Kh·ªüi t·∫°o
        updateImageCounter();
        updateStats();
    </script>
</body>
</html>
